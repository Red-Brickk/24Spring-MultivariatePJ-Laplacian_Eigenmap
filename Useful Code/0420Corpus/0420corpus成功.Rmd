---
title: "0420corpus"
author: "Brick"
date: "2024-04-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


本 R markdown 筆記本用於處理MNIST數據集。


# 引入必要的庫

```{r message=FALSE, warning=FALSE}
# install.packages("Rdimtools")
library(Rdimtools) # 用於實施拉普拉斯特征映射
library(plotly) # 用於交互式繪圖
```


# 檢查數據

```{r}
rawdf <- read.csv("D:/Study/Courses/2024Spring/multivariate/Project/code/0421MNIST/mnist_test.csv")

# 表格的第一列是單詞名，故排掉
df <- rawdf[1:1000,2:785]
lab <- rawdf[1:1000,1]

```

## 了解數據集的基本情況

```{r}
# 出现次数最多的单词对是？
max(df)
# 每个单词对平均出现多少次？
sum(df)/(300*600)
# # 每个单词见证了多少个单词对？
rsum <- apply(df, 1, sum)
hist(rsum, main="Row Sum (How many word pairs do the 300 words observe)", xlab="row sum")
cat("Row Sum Top 10\n")
sort(rsum,decreasing=T)[1:10]
cat("\nRow Sum Least 10\n")
sort(rsum,decreasing=F)[1:10]
# # 每个单词多少次作为语境词出现？
csum <- apply(df, 2, sum)
hist(csum, main="Column Sum (How often does a word be a context word)", xlab="column sum")
cat("\nColumn Sum Top 10\n")
sort(csum,decreasing=T)[1:10]
cat("\nColumn Sum Least 10\n")
sort(csum,decreasing=F)[1:10]
```


## 獲取鄰接矩陣函數 (by 旭晴)（用於查看圖結構）
```{r}
# 步驟2：使用k最近鄰計算鄰接矩陣
dataframe_to_adjmat <- function(df, k, tt){
  dist_matrix <- as.matrix(dist(df))  # 歐幾里得距離矩陣
  # 計算熱核權重
  weight_matrix <- exp(-dist_matrix^2 / tt)
  
  # 偵測每行的k+1個最小值（自身和k個鄰居）
  # 注意：此時所說的“偵測k+1個最小值”，並非指所得圖中每個點有k個鄰居，原因下陳。
  adj_matrix <- apply(weight_matrix, 1, function(row) {
    smallest <- order(row, decreasing = TRUE)[1:(k+1)]
    weights <- rep(0, length(row))
    weights[smallest] <- row[smallest]
    weights
  })
  
  adj_matrix <- (adj_matrix + t(adj_matrix)) / 2  # 確保矩陣是對稱的（無向圖）
  return(adj_matrix)
}
```

k 近鄰 只是為了確定一些鄰近的點。然而，會出現，某點A是不止k個點的k近鄰的情況。比方說，設置k=10,但A點是20個點的k近鄰。此時，是否要將A點與它們連接起來呢？站在距離空間的角度看，對稱比較符合直覺；在保留局部相鄰性的角度看，如果承認A點與B點局部相鄰，很難認為B點與A點不局部相鄰；站在數學處理的角度看，這樣形成的圖是無向圖。因此，我們選擇做
%%% adj_matrix <- (adj_matrix + t(adj_matrix)) / 2  # 確保矩陣是對稱的（無向圖）%%%
這樣的處理。

## 檢視構造出的圖，以及鄰居
```{r warning=TRUE}
# 可以嘗試不同的id和t,似乎t要到1000以上，鄰居之間才不會離得太遠。
id <- 99
k <- 10
cat("word",id,"is:", rownames(df)[id],"\n")
cat("Its neighbors in constructed graph, and the edge weights are:\n")
round(sort(dataframe_to_adjmat(df, k=k, tt=10000)[id,], decreasing = T)[1:20],3)
# cat("Frequent cooccurence words:\n")
# sort(df[id,],decreasing=T)[,1:10]
```

可認為拉普拉斯特征映射分兩步，一是由原始數據構建圖，二是根據圖找圖函數。數據降維表示的效果是否良好，關鍵在於構建圖。對於第二步，“找最平滑的圖函數”這一任務，已有解析解，我們重在闡釋，無法改進。但對於第一步，需要科學地對比、搜索，以找到該問題最良好的構建方案。

## 找拉普拉斯特征映射

```{r}
# 準備
tt <- 1e4
method <- "knn" # 選KNN還是ENN?
k <- 3 # 找幾個鄰居？
epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
# 將數據框轉換成矩陣，便於調用函數
# df_mat <- as.matrix(df, nrows=nrow(df))


# scale 意味著行和列的分離：你把列當做屬性，而不是什麼可以和行任意調換的東西
# 但 scale意味著你認為兩列之間沒有可比性。有嗎？有的。
df_mat <- as.matrix(scale(df), nrows=nrow(df))
```


### 嘗試自定義拉普拉斯特征映射函數
```{r}
library(igraph)
library(RSpectra)
my.lapeig <- function(epsilon,tt,df,ndim){
  # 步驟2：使用熱核權重和k最近鄰計算鄰接矩陣
  dist_matrix <- as.matrix(dist(df))  # 歐幾里得距離矩陣
  
  # 計算熱核權重
  weight_matrix <- exp(-(dist_matrix^2) / tt)
  
  count<-1
  # 保留每行k+1個最小值（自身和k個鄰居）
  adj_matrix <- apply(weight_matrix, 1, function(row) {
    # smallest <- order(row, decreasing = TRUE)[1:(k+1)]
    smallest <- which(dist_matrix[count,]<epsilon) # enn version
    # cat(smallest,"\n")
    count<- count+1
    weights <- rep(0, length(row))
    weights[smallest] <- row[smallest]
    # cat(row[smallest],"\n")
    weights
  })
  adj_matrix <- (adj_matrix + t(adj_matrix)) / 2  # 確保矩陣是對稱的  
  # 步驟3：構造圖拉普拉斯
  D <- diag(rowSums(adj_matrix))  # 度矩陣，加權度為各行之和
  L <- D - adj_matrix  # 未規範化的拉普拉斯
  
  # 步驟4：進行特徵分解
  # 進行特徵分解
  eigen_result <- eigs_sym(L, k = ndim, which = "SM")
  low_dim_embedding <- eigen_result$vectors

  return (list(Y=low_dim_embedding))
}
```

## 定義對比測試函數
```{r}
test <- function(df_mat,ndim,weighted,method,k,epsilon,tt,figmain,manual=FALSE){
  if (method=="knn"){
    type <- c("knn",k)
  }
  if (method=="enn"){
    type <- c("enn",epsilon)
  }
  if (!weighted){
    tt=1
  }
  
  if (manual){
    le1 <- my.lapeig(epsilon=epsilon,tt=tt, df=df_mat, ndim=ndim)
  }
  else{
      # 調用函數，對矩陣，先構造圖，再找它的拉普拉斯映射
    le1 <- do.lapeig(df_mat,ndim=ndim, kernelscale=tt,type=type, weighted=weighted)    
  }
  
  # 記錄映射值
  df_le1 <- as.data.frame(le1$Y)
  mapname <- c("map1","map2","map3","map4","map5")
  colnames(df_le1) <- mapname[1:ndim]
  rownames(df_le1) <- rownames(df)
  
  # 创建散点图
  p <- plot_ly(data = df_le1, x = ~map1, y = ~map3,color=lab, type = 'scatter', mode = 'markers') %>%
    
    # p <- plot_ly(data = df_le1, x = ~map1, y = ~map2, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>%
  # 添加文本标签
  # add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
    layout(title = figmain)
  print(p)
}
```



### 第一組實驗：找k
此處，我們先不引入熱核，選定觀察dim1 和 dim2，採用knn方法，比較不同k對降維效果的影響。

```{r}
method <- "knn" # 選KNN還是ENN?
weighted <- FALSE
k <- 3 # 找幾個鄰居？
epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
df_mat <- as.matrix(df, nrows=nrow(df))

# 需要時可用循環比較各參數值
for (k in 9:10){
  test(df_mat,weighted, method=method, k=k, ndim=3, figmain=paste("Laplacian Eigen Map, knn, k=",k))
}
```

### 第二組實驗：標準化後找k
此處，我們先不引入熱核，但對原始數據按列標準化，選定觀察dim1 和 dim2，採用knn方法，比較不同k對降維效果的影響。

```{r}
method <- "knn" # 選KNN還是ENN?
weighted <- FALSE
k <- 3 # 找幾個鄰居？
epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
df_mat <- as.matrix(scale(df), nrows=nrow(df))

# 需要時可用循環比較各參數值
for (k in 1:10){
  test(df_mat,weighted, method, k, epsilon, ndim=2, NULL, figmain=paste("Laplacian Eigen Map,column wise standardized, knn, k=",k))
}
```

### 第三組實驗：找tt
此處，我們引入熱核，選定觀察dim1 和 dim2，採用knn方法，選定k=8，比較不同tt對降維效果的影響。

```{r}
method <- "knn" # 選KNN還是ENN?
weighted <- TRUE
k <- 8 # 找幾個鄰居？
epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
df_mat <- as.matrix(df, nrows=nrow(df))

# 需要時可用循環比較各參數值
for (tt in c(5e5,6e5,7e5,8e5,9e5,1e6)){
  test(df_mat,weighted, method, k=k, ndim=3, tt=tt, figmain=paste("Laplacian Eigen Map, knn, weighted k=8, tt=",tt))
}
```
有一種到了臨界之後炸開的感覺，但是更大的tt也沒有起到什麼好的作用。


### 第四組實驗：找dim
此處，我們不引入熱核，採用knn方法，選定k=8，比較數據點在不同維度上的分佈情況。

```{r}
method <- "knn" # 選KNN還是ENN?
weighted <- FALSE
k <- 8 # 找幾個鄰居？
epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
ndim <- 4
df_mat <- as.matrix(df, nrows=nrow(df))

# 調用函數，對矩陣，先構造圖，再找它的拉普拉斯映射
le1 <- do.lapeig(df_mat,ndim=ndim, kernelscale=tt,type=c(method,k), weighted=weighted)

# 記錄映射值
df_le1 <- as.data.frame(le1$Y)
mapname <- c("map1","map2","map3","map4","map5")


colnames(df_le1) <- mapname[1:ndim]
rownames(df_le1) <- rownames(df)


# 创建散点图
plist <- list()
plist[[1]] <- plot_ly(data = df_le1, x = ~map1, y = ~map2, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim1 and dim2"))


plist[[2]] <- plot_ly(data = df_le1, x = ~map1, y = ~map3, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim1 and dim3"))


plist[[3]] <- plot_ly(data = df_le1, x = ~map2, y = ~map3, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim2 and dim3"))


plist[[4]] <- plot_ly(data = df_le1, x = ~map1, y = ~map4, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim1 and dim4"))

plist[[5]] <- plot_ly(data = df_le1, x = ~map2, y = ~map4, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim2 and dim4"))

plist[[6]] <- plot_ly(data = df_le1, x = ~map3, y = ~map4, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim3 and dim4"))

print(plist)

```



# 嘗試用kmeans方法對降維結果做聚類
```{r}
# Select number of clusters
k <- 7
set.seed(123)
# # Build model with k clusters: km.out
# km.out <- kmeans(df_le1, centers = k, nstart = 20)
# lab <- km.out$cluster

library(dplyr)
colors <- c("red", "blue", "green", "purple","cyan","lightblue","lightgreen","black","yellow","magenta")
labnames <- c("情態動詞","特殊名詞","難分辨","動詞及過去式","代詞","系動詞、介詞","難分辨2","aaa","bbb","ccc")

# 创建散点图
plist <- list()
plist[[1]] <- plot_ly(data = df_le1, x = ~map1, y = ~map2, color=colors[lab+1], name = labnames[lab+1],type = 'scatter', mode = 'markers') %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list( size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim1 and dim2"))


plist[[2]] <- plot_ly(data = df_le1, x = ~map1, y = ~map3, color=colors[lab], name = labnames[lab],type = 'scatter', mode = 'markers') %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list( size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim1 and dim3"))


plist[[3]] <- plot_ly(data = df_le1, x = ~map2, y = ~map3, color=colors[lab],name = labnames[lab],type = 'scatter', mode = 'markers') %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list( size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim2 and dim3"))


plist[[4]] <- plot_ly(data = df_le1, x = ~map1, y = ~map4, color=colors[lab],name = labnames[lab],type = 'scatter', mode = 'markers') %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim1 and dim4"))

plist[[5]] <- plot_ly(data = df_le1, x = ~map2, y = ~map4, color=colors[lab],name = labnames[lab],type = 'scatter', mode = 'markers') %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list( size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim2 and dim4"))

plist[[6]] <- plot_ly(data = df_le1, x = ~map3, y = ~map4, color=colors[lab],name = labnames[lab],type = 'scatter', mode = 'markers') %>% 
  add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(size = 10))  %>%
  layout(title = paste("Laplacian Eigen Map, knn, weighted k=8, dim3 and dim4"))

print(plist[[1]])

```



### 第五組實驗：找e
此處，我們先不引入熱核，選定觀察dim1 和 dim2，採用enn方法，比較不同e對降維效果的影響。

```{r}
method <- "enn" # 選KNN還是ENN?
weighted <- FALSE
# k <- 3 # 找幾個鄰居？
# epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
df_mat <- as.matrix(df, nrows=nrow(df))
hist(dist(df_mat),main="Histogram of pointwise distances", xlab="distance")

# 需要時可用循環比較各參數值
for (epsilon in c(2500,2600,2700,2800,2900,3000)){
  test(df_mat,weighted,method, epsilon=epsilon, ndim=3, tt=1, figmain=paste("Laplacian Eigen Map, enn, weighted epsilon=",epsilon))
}

```


以下是失敗的嘗試……

嘗試1：不用test函數，直接寫代碼在循環裡面。
```{r}
method <- "enn" # 選KNN還是ENN?
weighted <- FALSE
k <- 3 # 找幾個鄰居？
epsilon <- 0.5 # 相鄰的閾值？（初得到數據集不了解其距離尺度，需要多探索）
df_mat <- as.matrix(df, nrows=nrow(df))

# 需要時可用循環比較各參數值
for (epsilon in (1:10)*100+2000){
    # 調用函數，對矩陣，先構造圖，再找它的拉普拉斯映射
    le1 <- do.lapeig(df_mat,ndim=ndim,type=c("enn",epsilon), weighted=FALSE)
  # 記錄映射值
  df_le1 <- as.data.frame(le1$Y)
  mapname <- c("map1","map2","map3","map4","map5")
  colnames(df_le1) <- mapname[1:ndim]
  rownames(df_le1) <- rownames(df)
  
  # 创建散点图
  p <- plot_ly(data = df_le1, x = ~map2, y = ~map3, type = 'scatter', mode = 'markers', marker = list(color = 'rgba(0, 0, 255, 0.5)')) %>%
    # 添加文本标签
    add_text(text = rownames(df_le1), textposition = 'top', showlegend = FALSE, hoverinfo = 'text', textfont = list(color = 'blue', size = 10))  %>%
    layout(title = paste("Laplacian Eigen Map, enn, weighted epsilon=",epsilon))
  print(p)
}
```


